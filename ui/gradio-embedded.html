<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comindware Platform Documentation Assistant</title>
    
    <!-- Preconnect to KB site fonts for faster loading when embedded -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://kb.comindware.ru">
    
    <!-- Open Sans font with Cyrillic support -->
    <link type="text/css" rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:100,300,500,300italic,400,400italic,700&amp;subset=latin,cyrillic">
    
    <!-- CMW Widget Theme -->
    <link rel="stylesheet" href="cmw-widget-theme.css">
</head>
<body>
    <!-- Floating Chat Widget -->
    <div id="chat-widget" class="chat-widget">
        <!-- Toggle Button -->
        <button 
            id="chat-toggle" 
            class="chat-toggle" 
            aria-label="Open chat assistant"
            title="Open chat assistant">
            ðŸ’¬
        </button>

        <!-- Widget Container -->
        <div id="chat-container" class="chat-container hidden">
            <!-- Custom resize handle (top-left) -->
            <div class="chat-container-resize-handle" id="resize-handle"></div>
            
            <!-- Header -->
            <div class="chat-header">
                <h3>Comindware Assistant</h3>
                <button 
                    id="close-chat" 
                    class="close-chat" 
                    aria-label="Close chat"
                    title="Close chat">
                    Ã—
                </button>
            </div>

            <!-- Gradio App Container -->
            <div class="gradio-app-container">
                <div id="loading-indicator" class="loading-indicator">
                    Loading assistant...
                </div>
                <gradio-app id="gradio-app" src="" style="display: none;"></gradio-app>
            </div>
        </div>
    </div>

    <!-- Gradio JavaScript SDK -->
    <script
        type="module"
        src="https://gradio.s3-us-west-2.amazonaws.com/5.49.1/gradio.js"
    ></script>

    <script>
        // Configuration
        // Set your Gradio app URL here, or it will use the default
        const GRADIO_URL = window.GRADIO_URL || '0.0.0.0:7860';
        
        // Ensure URL has protocol
        function normalizeUrl(url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                // Default to http for local development, https for production domains
                if (url.includes('localhost') || url.match(/^\d+\.\d+\.\d+\.\d+/)) {
                    return `http://${url}`;
                }
                return `https://${url}`;
            }
            return url;
        }

        const gradioAppUrl = normalizeUrl(GRADIO_URL);

        // DOM elements - declared early for use in functions
        const chatToggle = document.getElementById('chat-toggle');
        const chatContainer = document.getElementById('chat-container');
        const closeChat = document.getElementById('close-chat');
        const gradioApp = document.getElementById('gradio-app');
        const loadingIndicator = document.getElementById('loading-indicator');
        const resizeHandle = document.getElementById('resize-handle');
        
        // State management
        const WIDGET_STORAGE_KEY = 'cmw_chat_widget_state';
        
        let isInitialized = false;
        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;
        let resizeStartLeft = 0;
        let resizeStartBottom = 0;
        
        function getStoredState() {
            try {
                const stored = localStorage.getItem(WIDGET_STORAGE_KEY);
                return stored ? JSON.parse(stored) : { isOpen: false };
            } catch {
                return { isOpen: false };
            }
        }

        function saveState(state) {
            try {
                // Also save container size and position if it exists
                if (chatContainer && !isContainerHidden()) {
                    const rect = chatContainer.getBoundingClientRect();
                    state.width = rect.width;
                    state.height = rect.height;
                    state.left = rect.left;
                    state.bottom = window.innerHeight - rect.bottom;
                }
                localStorage.setItem(WIDGET_STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save widget state:', e);
            }
        }

        // Check if container is hidden (new logic using visibility)
        function isContainerHidden() {
            return chatContainer.classList.contains('hidden') || 
                   getComputedStyle(chatContainer).visibility === 'hidden';
        }

        // Restore container size from saved state
        function restoreContainerSize() {
            const storedState = getStoredState();
            if (storedState.width && storedState.height) {
                chatContainer.style.width = storedState.width + 'px';
                chatContainer.style.height = storedState.height + 'px';
            }
            // Also restore position if saved
            if (storedState.left !== undefined) {
                chatContainer.style.left = storedState.left + 'px';
                chatContainer.style.right = 'auto';
            }
            if (storedState.bottom !== undefined) {
                chatContainer.style.bottom = storedState.bottom + 'px';
            }
        }

        // Save size on resize
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const storedState = getStoredState();
                saveState(storedState);
            }, 300); // Debounce resize events
        }

        // Custom resize functionality from top-left corner
        function startResize(e) {
            if (isContainerHidden()) return;
            
            isResizing = true;
            const rect = chatContainer.getBoundingClientRect();
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            resizeStartWidth = rect.width;
            resizeStartHeight = rect.height;
            resizeStartLeft = rect.left;
            resizeStartBottom = window.innerHeight - rect.bottom;
            
            e.preventDefault();
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }

        function doResize(e) {
            if (!isResizing) return;
            
            const deltaX = resizeStartX - e.clientX; // Inverted because top-left
            const deltaY = resizeStartY - e.clientY; // Inverted because top-left
            
            let newWidth = resizeStartWidth + deltaX;
            let newHeight = resizeStartHeight + deltaY;
            let newLeft = resizeStartLeft - deltaX;
            let newBottom = resizeStartBottom + deltaY;
            
            // Apply min/max constraints
            const minWidth = parseInt(getComputedStyle(chatContainer).minWidth);
            const minHeight = parseInt(getComputedStyle(chatContainer).minHeight);
            const maxWidth = parseInt(getComputedStyle(chatContainer).maxWidth) || window.innerWidth * 0.9;
            const maxHeight = parseInt(getComputedStyle(chatContainer).maxHeight) || window.innerHeight * 0.9;
            
            if (newWidth < minWidth) {
                newWidth = minWidth;
                newLeft = resizeStartLeft - (newWidth - resizeStartWidth);
            }
            if (newWidth > maxWidth) {
                newWidth = maxWidth;
                newLeft = resizeStartLeft - (newWidth - resizeStartWidth);
            }
            if (newHeight < minHeight) {
                newHeight = minHeight;
                newBottom = resizeStartBottom + (resizeStartHeight - newHeight);
            }
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newBottom = resizeStartBottom + (resizeStartHeight - newHeight);
            }
            
            // Constrain to viewport
            if (newLeft < 0) {
                newLeft = 0;
                newWidth = resizeStartWidth + resizeStartLeft;
            }
            if (newBottom < 0) {
                newBottom = 0;
                newHeight = resizeStartHeight + resizeStartBottom;
            }
            
            chatContainer.style.width = newWidth + 'px';
            chatContainer.style.height = newHeight + 'px';
            chatContainer.style.left = newLeft + 'px';
            chatContainer.style.right = 'auto';
            chatContainer.style.bottom = newBottom + 'px';
            
            handleResize();
        }

        function stopResize() {
            if (isResizing) {
                isResizing = false;
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }

        // Toggle widget visibility
        function toggleWidget(forceState = null) {
            const isOpen = forceState !== null ? forceState : !chatContainer.classList.contains('hidden');
            const newState = !isOpen;

            if (newState) {
                // Show immediately
                chatContainer.classList.remove('hidden');
                
                // Use requestAnimationFrame to ensure element is visible before animation
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        chatContainer.classList.add('show');
                    });
                });
                
                // Hide loading indicator if Gradio is already initialized
                if (isInitialized && loadingIndicator) {
                    loadingIndicator.classList.add('hidden');
                }
            } else {
                chatContainer.classList.remove('show');
                setTimeout(() => {
                    chatContainer.classList.add('hidden');
                }, 300); // Match --cmw-transition-duration (0.3s)
            }

            saveState({ isOpen: newState });
        }

        // Initialize Gradio app (preloading on page load)
        function initializeGradioApp() {
            if (isInitialized) return;

            gradioApp.setAttribute('src', gradioAppUrl);
            gradioApp.style.display = 'block';
            
            // Wait for Gradio to load
            gradioApp.addEventListener('load', () => {
                loadingIndicator.classList.add('hidden');
                isInitialized = true;
            });

            // Fallback: hide loading after timeout
            setTimeout(() => {
                if (loadingIndicator && !loadingIndicator.classList.contains('hidden')) {
                    loadingIndicator.classList.add('hidden');
                }
            }, 5000);
        }

        // Event listeners
        chatToggle.addEventListener('click', () => toggleWidget());
        closeChat.addEventListener('click', () => toggleWidget(false));
        
        // Custom resize handle
        if (resizeHandle) {
            resizeHandle.addEventListener('mousedown', startResize);
        }

        // Keyboard accessibility
        document.addEventListener('keydown', (e) => {
            // Escape key to close
            if (e.key === 'Escape' && !isContainerHidden()) {
                toggleWidget(false);
            }
        });

        // Restore previous state on page load
        const storedState = getStoredState();
        
        // Restore container size first
        restoreContainerSize();
        
        // Add resize observer to save size changes
        const resizeObserver = new ResizeObserver(() => {
            if (!isContainerHidden()) {
                handleResize();
            }
        });
        resizeObserver.observe(chatContainer);
        
        // Preload Gradio app immediately (not lazy loading)
        // This ensures it's ready when the user clicks the button
        initializeGradioApp();
        
        if (storedState.isOpen) {
            // Small delay to ensure DOM is ready
            setTimeout(() => toggleWidget(true), 100);
        }

        // Expose configuration globally for easy override
        window.GRADIO_URL = gradioAppUrl;
    </script>
</body>
</html>
