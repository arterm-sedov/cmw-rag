<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ассистент базы знаний Comindware</title>
    
    <!-- Preconnect to KB site fonts for faster loading when embedded -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    
    <!-- Open Sans font with Cyrillic support -->
    <link type="text/css" rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:100,300,500,300italic,400,400italic,700&amp;subset=latin,cyrillic">
    
    <!-- CMW Widget Theme -->
    <link rel="stylesheet" href="assets/css/cmw-widget-theme.css">
    <link href="assets/fontawesome/css/fontawesome.min.css" rel="stylesheet">
    <link href="assets/fontawesome/css/brands.min.css" rel="stylesheet">
    <link href="assets/fontawesome/css/solid.min.css" rel="stylesheet">
    <link href="assets/fontawesome/css/light.min.css" rel="stylesheet">
    <style>
        /* Prevent outer page from introducing an extra scrollbar.
           The only scrollable area should be the chatbot inside the widget. */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- Floating Chat Widget -->
    <div id="cmw-widget" class="cmw-widget">
        <!-- Toggle Button -->
        <button 
            id="cmw-widget-toggle" 
            class="cmw-widget-toggle" 
            aria-label="Открыть Ассистент базы знаний Comindware"
            title="Открыть Ассистент базы знаний Comindware">
            <i class="fa-light fa-microchip-ai"></i>
        </button>

        <!-- Widget Container -->
        <div id="cmw-widget-container" class="cmw-widget-container cmw-widget-hidden">
            <!-- Custom resize handle (top-left) -->
            <div class="cmw-widget-container-resize-handle" id="cmw-widget-resize-handle"></div>
            
            <!-- Header -->
            <div class="cmw-widget-header">
                <h3>Ассистент базы знаний Comindware</h3>
                <button 
                    id="cmw-widget-close" 
                    class="cmw-widget-close" 
                    aria-label="Закрыть ассистент"
                    title="Закрыть ассистент">
                    <i class="fa-light fa-xmark"></i>
                </button>
            </div>

            <!-- Gradio App Container -->
            <div class="cmw-widget-gradio-container">
                <div id="cmw-widget-loading" class="cmw-widget-loading">
                    Загрузка ассистента...
                </div>
                <gradio-app id="cmw-widget-gradio-app" src="" style="display: none;"></gradio-app>
            </div>
        </div>
    </div>

    <!-- Gradio JavaScript SDK -->
    <script
        type="module"
        src="https://gradio.s3-us-west-2.amazonaws.com/6.5.1/gradio.js"
    ></script>

    <script>
        // Ensure URL has protocol
        function normalizeUrl(url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                if (url.includes('localhost') || url.match(/^\d+\.\d+\.\d+\.\d+/)) {
                    return `http://${url}`;
                }
                return `https://${url}`;
            }
            return url;
        }

        let gradioAppUrl;

        // DOM elements - declared early for use in functions
        const chatToggle = document.getElementById('cmw-widget-toggle');
        const chatContainer = document.getElementById('cmw-widget-container');
        const closeChat = document.getElementById('cmw-widget-close');
        const gradioApp = document.getElementById('cmw-widget-gradio-app');
        const loadingIndicator = document.getElementById('cmw-widget-loading');
        const resizeHandle = document.getElementById('cmw-widget-resize-handle');
        
        // State management
        const WIDGET_STORAGE_KEY = 'cmw_chat_widget_state';
        
        // Constants for chatbot height calculation
        // Slightly reduced so the chat block is ~4–5% shorter than original,
        // and a bit smaller than the last revision to avoid extra scrollbars.
        const CHATBOT_HEIGHT_PERCENTAGE_NARROW = 0.70; // 70% of available height when narrow
        const CHATBOT_HEIGHT_PERCENTAGE_WIDE = 0.81; // 81% of available height when wide
        const WIDGET_WIDTH_THRESHOLD = 470; // Width threshold in pixels (narrow vs wide)
        const HEADER_HEIGHT_FALLBACK = 60; // Fallback header height in pixels
        const RESIZE_DEBOUNCE_MS = 300; // Debounce delay for resize events
        const WIDGET_SHOW_DELAY_MS = 100; // Delay before updating height after widget shows
        const WIDGET_OPEN_DELAY_MS = 200; // Delay before updating height after widget opens
        
        let isInitialized = false;
        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;
        let resizeStartLeft = 0;
        let resizeStartBottom = 0;
        let activePointerId = null;
        
        function getStoredState() {
            try {
                const stored = localStorage.getItem(WIDGET_STORAGE_KEY);
                return stored ? JSON.parse(stored) : { isOpen: true };
            } catch {
                return { isOpen: true };
            }
        }

        function saveState(state) {
            try {
                // Also save container size and position if it exists and is visible
                if (chatContainer && !isContainerHidden() && chatContainer.classList.contains('show')) {
                    const rect = chatContainer.getBoundingClientRect();
                    state.width = rect.width;
                    state.height = rect.height;
                    const calculatedBottom = window.innerHeight - rect.bottom;
                    // Only save position if it's valid (non-negative and reasonable)
                    if (calculatedBottom >= 0 && calculatedBottom < window.innerHeight) {
                        state.left = rect.left;
                        state.bottom = calculatedBottom;
                    }
                }
                localStorage.setItem(WIDGET_STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Не удалось сохранить состояние виджета:', e);
            }
        }

        // Check if container is hidden (new logic using visibility)
        function isContainerHidden() {
            return chatContainer.classList.contains('cmw-widget-hidden') || 
                   getComputedStyle(chatContainer).visibility === 'hidden';
        }

        // Restore container size from saved state
        function restoreContainerSize() {
            const storedState = getStoredState();
            if (storedState.width && storedState.height) {
                const width = Math.max(storedState.width, parseInt(getComputedStyle(chatContainer).minWidth) || 320);
                const height = Math.max(storedState.height, parseInt(getComputedStyle(chatContainer).minHeight) || 400);
                chatContainer.style.width = width + 'px';
                chatContainer.style.height = height + 'px';
            }
            // Only restore position if values are valid (non-negative and within reasonable bounds)
            if (storedState.left !== undefined && storedState.left >= 0 && storedState.left < window.innerWidth) {
                chatContainer.style.left = storedState.left + 'px';
                chatContainer.style.right = 'auto';
            }
            if (storedState.bottom !== undefined && storedState.bottom >= 0 && storedState.bottom < window.innerHeight) {
                chatContainer.style.bottom = storedState.bottom + 'px';
            }
        }

        // Update chatbot height to percentage of container height.
        // Uses 70% when narrow (<= 470px) and 81% when wide (> 470px),
        // leaving room for the header and input while keeping only the
        // internal chatbot scrollbar active.
        function updateChatbotHeight() {
            if (isContainerHidden()) return;

            const containerRect = chatContainer.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Determine percentage based on width
            const isWide = containerWidth > WIDGET_WIDTH_THRESHOLD;
            const heightPercentage = isWide
                ? CHATBOT_HEIGHT_PERCENTAGE_WIDE
                : CHATBOT_HEIGHT_PERCENTAGE_NARROW;

            // Header height
            const headerHeight =
                chatContainer
                    .querySelector('.cmw-widget-header')
                    ?.getBoundingClientRect().height || HEADER_HEIGHT_FALLBACK;

            // Approximate height of the textbox + buttons area
            const textboxHeight = 100;

            // Small buffer for borders/padding so we don't force an extra outer scrollbar
            const paddingBuffer = 16;

            const availableHeight =
                containerHeight - headerHeight - textboxHeight - paddingBuffer;

            const chatbotHeight = Math.max(300, availableHeight * heightPercentage);

            // Drive the CSS variable; CSS on the chatbot container uses
            // max-height: var(--chatbot-height) and overflow-y: auto,
            // so only the inner chat log scrolls.
            chatContainer.style.setProperty(
                '--chatbot-height',
                `${chatbotHeight}px`,
            );
        }

        // Save size on resize
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateChatbotHeight();
                const storedState = getStoredState();
                saveState(storedState);
            }, RESIZE_DEBOUNCE_MS);
        }

        // Custom resize functionality from top-left corner
        function startResize(e) {
            if (isContainerHidden()) return;
            
            // Prefer pointer events; capture to avoid loss over iframes
            if (e.pointerId !== undefined && e.isPrimary !== false) {
                activePointerId = e.pointerId;
                try { resizeHandle.setPointerCapture(activePointerId); } catch {}
            }

            isResizing = true;
            const rect = chatContainer.getBoundingClientRect();
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            resizeStartWidth = rect.width;
            resizeStartHeight = rect.height;
            resizeStartLeft = rect.left;
            resizeStartBottom = window.innerHeight - rect.bottom;
            
            e.preventDefault();
            // If a KB iframe exists on the page, disable pointer events during resize
            const kbIframe = document.getElementById('kb-iframe');
            if (kbIframe) kbIframe.style.pointerEvents = 'none';
            
            document.addEventListener('pointermove', doResize);
            document.addEventListener('pointerup', stopResize);
        }

        function doResize(e) {
            if (!isResizing) return;
            if (activePointerId !== null && e.pointerId !== activePointerId) return;
            
            const deltaX = resizeStartX - e.clientX; // Inverted because top-left
            const deltaY = resizeStartY - e.clientY; // Inverted because top-left
            
            // Keep bottom edge fixed - only top-left corner moves
            let newWidth = resizeStartWidth + deltaX;
            let newHeight = resizeStartHeight + deltaY;
            let newLeft = resizeStartLeft - deltaX;
            const newBottom = resizeStartBottom;
            
            // Apply min/max constraints
            const minWidth = parseInt(getComputedStyle(chatContainer).minWidth);
            const minHeight = parseInt(getComputedStyle(chatContainer).minHeight);
            const maxWidth = parseInt(getComputedStyle(chatContainer).maxWidth) || window.innerWidth * 0.9;
            const maxHeight = parseInt(getComputedStyle(chatContainer).maxHeight) || window.innerHeight * 0.9;
            
            if (newWidth < minWidth) {
                newWidth = minWidth;
                newLeft = resizeStartLeft - (newWidth - resizeStartWidth);
            }
            if (newWidth > maxWidth) {
                newWidth = maxWidth;
                newLeft = resizeStartLeft - (newWidth - resizeStartWidth);
            }
            if (newHeight < minHeight) {
                newHeight = minHeight;
            }
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
            }
            
            // Constrain to viewport - ensure bottom stays visible and top within viewport
            if (newLeft < 0) {
                newLeft = 0;
                newWidth = resizeStartWidth + resizeStartLeft;
            }
            const availableHeight = window.innerHeight - newBottom;
            if (newHeight > availableHeight) {
                newHeight = Math.max(minHeight, availableHeight);
            }
            
            chatContainer.style.width = newWidth + 'px';
            chatContainer.style.height = newHeight + 'px';
            chatContainer.style.left = newLeft + 'px';
            chatContainer.style.right = 'auto';
            chatContainer.style.bottom = newBottom + 'px';
            
            // Update chatbot height immediately during resize using requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                updateChatbotHeight();
            });
            handleResize();
        }

        function stopResize(e) {
            if (isResizing) {
                isResizing = false;
                document.removeEventListener('pointermove', doResize);
                document.removeEventListener('pointerup', stopResize);
                const kbIframe = document.getElementById('kb-iframe');
                if (kbIframe) kbIframe.style.pointerEvents = '';
                if (activePointerId !== null) {
                    try { resizeHandle.releasePointerCapture(activePointerId); } catch {}
                    activePointerId = null;
                }
            }
        }

        // Toggle widget visibility
        function toggleWidget(forceState = null) {
            let newState;
            if (forceState !== null) {
                // If forceState is provided, use it directly
                newState = forceState;
            } else {
                // Otherwise, toggle based on current state
                const isOpen = !chatContainer.classList.contains('cmw-widget-hidden');
                newState = !isOpen;
            }

            if (newState) {
                // Show immediately
                chatContainer.classList.remove('cmw-widget-hidden');
                // Run an immediate height update so the very first paint matches the container
                updateChatbotHeight();
                
                // Use requestAnimationFrame to ensure element is fully laid out before a second adjustment
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        chatContainer.classList.add('show');
                        // Update chatbot height again right after the show animation starts
                        updateChatbotHeight();
                        // And once more after a short delay as a safety net for slower layouts
                        setTimeout(() => updateChatbotHeight(), WIDGET_SHOW_DELAY_MS);
                    });
                });
                
                // Hide loading indicator if Gradio is already initialized
                if (isInitialized && loadingIndicator) {
                    loadingIndicator.classList.add('cmw-widget-hidden');
                }
            } else {
                chatContainer.classList.remove('show');
                setTimeout(() => {
                    chatContainer.classList.add('cmw-widget-hidden');
                }, RESIZE_DEBOUNCE_MS); // Match --cmw-transition-duration
            }

            saveState({ isOpen: newState });
        }

        // Initialize Gradio app (preloading on page load)
        function initializeGradioApp(url) {
            if (isInitialized) return;

            gradioApp.setAttribute('src', url);
            gradioApp.style.display = 'block';
            
            // Wait for Gradio to load
            gradioApp.addEventListener('load', () => {
                loadingIndicator.classList.add('cmw-widget-hidden');
                isInitialized = true;
                // Once Gradio is ready inside the popup, immediately align the chat height
                // to the current container, then refine after a short delay.
                if (!isContainerHidden()) {
                    updateChatbotHeight();
                    setTimeout(() => updateChatbotHeight(), WIDGET_OPEN_DELAY_MS);
                }
            });

            // Fallback: hide loading after timeout
            setTimeout(() => {
                if (loadingIndicator && !loadingIndicator.classList.contains('cmw-widget-hidden')) {
                    loadingIndicator.classList.add('cmw-widget-hidden');
                }
            }, 5000);
        }

        // Event listeners
        if (chatToggle) {
            chatToggle.addEventListener('click', () => toggleWidget());
        }
        if (closeChat) {
            closeChat.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleWidget(false);
            });
        }
        
        // Custom resize handle
        if (resizeHandle) {
            resizeHandle.addEventListener('pointerdown', startResize);
        }

        // Keyboard accessibility
        document.addEventListener('keydown', (e) => {
            // Escape key to close
            if (e.key === 'Escape' && !isContainerHidden()) {
                toggleWidget(false);
            }
        });

        // Initialize on page load
        (async () => {
            // Load GRADIO_URL from JSON config or window.GRADIO_URL
            let url;
            try {
                const config = await fetch('gradio-config.json').then(r => r.json());
                url = config.GRADIO_URL;
            } catch {
                url = window.GRADIO_URL;
            }
            
            if (!url) {
                console.error('GRADIO_URL не настроен');
                return;
            }
            
            gradioAppUrl = normalizeUrl(url);
            
            window.GRADIO_URL = gradioAppUrl;
            
            // Restore previous state on page load
            const storedState = getStoredState();
            
            // Validate and clean stored position values
            const hasValidPosition = storedState.bottom !== undefined && 
                                     storedState.bottom >= 0 && 
                                     storedState.bottom < window.innerHeight &&
                                     storedState.left !== undefined &&
                                     storedState.left >= 0 && 
                                     storedState.left < window.innerWidth;
            
            // If position is invalid, clear it to use default positioning
            if (!hasValidPosition && (storedState.bottom !== undefined || storedState.left !== undefined)) {
                delete storedState.bottom;
                delete storedState.left;
                localStorage.setItem(WIDGET_STORAGE_KEY, JSON.stringify(storedState));
            }
            
            restoreContainerSize();
            
            // Add resize observer to save size changes and update chatbot height
            const resizeObserver = new ResizeObserver(() => {
                if (!isContainerHidden()) {
                    updateChatbotHeight();
                    handleResize();
                }
            });
            resizeObserver.observe(chatContainer);
            
            // Preload Gradio app
            initializeGradioApp(gradioAppUrl);
            
            if (storedState.isOpen) {
                setTimeout(() => {
                    toggleWidget(true);
                    // Update chatbot height after widget opens
                    setTimeout(() => updateChatbotHeight(), WIDGET_OPEN_DELAY_MS);
                }, WIDGET_SHOW_DELAY_MS);
            }
        })();
    </script>
</body>
</html>
